{"version":3,"file":"static/js/195.61b5997e.chunk.js","mappings":"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","sources":["../node_modules/src/controls/OrbitControls.ts","../node_modules/@react-three/drei/core/OrbitControls.js"],"sourcesContent":["import {\n  EventDispatcher,\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\n\nconst _ray = new Ray()\nconst _plane = new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function dollyOut(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale /= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyIn(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale *= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n"],"names":["_ray","Ray","_plane","Plane","TILT_LIMIT","Math","cos","PI","moduloWrapAround","offset","capacity","OrbitControls","EventDispatcher","constructor","object","domElement","__publicField","Vector3","Infinity","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","this","target0","target","clone","position0","position","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","setPolarAngle","value","currentPhi","phiDist","abs","sphericalDelta","scope","update","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","addEventListener","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","removeEventListener","saveState","copy","reset","updateProjectionMatrix","dispatchEvent","changeEvent","state","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","min","minAzimuthAngle","max","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","add","zoomToCursor","performCursorZoom","isOrthographicCamera","radius","clampDistance","scale","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","set","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","length","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","x","y","unproject","minZoom","maxZoom","mouseAfter","console","warn","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","OrthographicCamera","distanceToSquared","EPS","quaternion","connect","style","touchAction","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","dispose","_a","_b","_c","_d","_e","ownerDocument","onPointerMove","_f","type","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","enablePan","dollyOut","dollyScale","enableZoom","dollyIn","updateMouseParameters","event","rect","getBoundingClientRect","clientX","clientY","w","width","h","height","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","push","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","pointerId","i","splice","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","needsUpdate","code","keys","keyPanSpeed","handleKeyDown","pointer","React","_ref","ref","makeDefault","camera","regress","keyEvents","onChange","onStart","onEnd","restProps","invalidate","useThree","defaultCamera","gl","events","setEvents","get","performance","explCamera","explDomElement","connected","controls","OrbitControls$1","useFrame","callback","e","onStartCb","onEndCb","old","_extends"],"sourceRoot":""}