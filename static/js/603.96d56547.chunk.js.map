{"version":3,"file":"static/js/603.96d56547.chunk.js","mappings":"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","sources":["../node_modules/@react-three/drei/core/Texture.js","../node_modules/src/lines/LineSegmentsGeometry.js","../node_modules/src/lines/LineMaterial.js","../node_modules/src/_polyfill/uv1.ts","../node_modules/src/lines/LineSegments2.js","../node_modules/src/lines/LineGeometry.js","../node_modules/src/lines/Line2.js","../node_modules/@react-three/drei/core/Line.js","components/Ball/Ball.jsx","components/GameLogic/GameLogic.jsx"],"sourcesContent":["import * as React from 'react';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\nimport { TextureLoader, Texture as Texture$1 } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input, onLoad) {\n  const gl = useThree(state => state.gl);\n  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);\n  useLayoutEffect(() => {\n    onLoad == null || onLoad(textures);\n  }, [onLoad]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  useEffect(() => {\n    if ('initTexture' in gl) {\n      let textureArray = [];\n      if (Array.isArray(textures)) {\n        textureArray = textures;\n      } else if (textures instanceof Texture$1) {\n        textureArray = [textures];\n      } else if (IsObject(textures)) {\n        textureArray = Object.values(textures);\n      }\n      textureArray.forEach(texture => {\n        if (texture instanceof Texture$1) {\n          gl.initTexture(texture);\n        }\n      });\n    }\n  }, [gl, textures]);\n  const mappedTextures = useMemo(() => {\n    if (IsObject(input)) {\n      const keyed = {};\n      let i = 0;\n      for (const key in input) keyed[key] = textures[i++];\n      return keyed;\n    } else {\n      return textures;\n    }\n  }, [input, textures]);\n  return mappedTextures;\n}\nuseTexture.preload = url => useLoader.preload(TextureLoader, url);\nuseTexture.clear = input => useLoader.clear(TextureLoader, input);\n\n//\n\nconst Texture = ({\n  children,\n  input,\n  onLoad\n}) => {\n  const ret = useTexture(input, onLoad);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children == null ? void 0 : children(ret));\n};\n\nexport { IsObject, Texture, useTexture };\n","import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = new Box3()\nconst _vector = new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n * }\n */\n\nimport { ShaderMaterial, UniformsLib, UniformsUtils, Vector2, REVISION } from 'three'\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n\n      uniforms: UniformsUtils.clone(\n        UniformsUtils.merge([\n          UniformsLib.common,\n          UniformsLib.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new Vector2(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n          },\n        ]),\n      ),\n\n      vertexShader: /* glsl */ `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */ `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`,\n      clipping: true, // required for clipping support\n    })\n\n    this.isLineMaterial = true\n\n    this.onBeforeCompile = function () {\n      if (this.transparent) {\n        this.defines.USE_LINE_COLOR_ALPHA = '1'\n      } else {\n        delete this.defines.USE_LINE_COLOR_ALPHA\n      }\n    }\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n\n        set: function (value) {\n          this.uniforms.diffuse.value = value\n        },\n      },\n\n      worldUnits: {\n        enumerable: true,\n\n        get: function () {\n          return 'WORLD_UNITS' in this.defines\n        },\n\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = ''\n          } else {\n            delete this.defines.WORLD_UNITS\n          }\n        },\n      },\n\n      linewidth: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.linewidth.value\n        },\n\n        set: function (value) {\n          this.uniforms.linewidth.value = value\n        },\n      },\n\n      dashed: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_DASH' in this.defines)\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = ''\n          } else {\n            delete this.defines.USE_DASH\n          }\n        },\n      },\n\n      dashScale: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashScale.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashScale.value = value\n        },\n      },\n\n      dashSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashSize.value = value\n        },\n      },\n\n      dashOffset: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashOffset.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashOffset.value = value\n        },\n      },\n\n      gapSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.gapSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.gapSize.value = value\n        },\n      },\n\n      opacity: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      resolution: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.resolution.value\n        },\n\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value)\n        },\n      },\n\n      alphaToCoverage: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)\n        },\n\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = ''\n            this.extensions.derivatives = true\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE\n            this.extensions.derivatives = false\n          }\n        },\n      },\n    })\n\n    this.setValues(parameters)\n  }\n}\n\nexport { LineMaterial }\n","import { version } from \"./constants\";\n\n/** uv2 renamed to uv1 in r125\n * \n * https://github.com/mrdoob/three.js/pull/25943\n*/\nexport const UV1 = version >= 125 ? 'uv1' : 'uv2'","import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3()\nconst _end = new Vector3()\n\nconst _start4 = new Vector4()\nconst _end4 = new Vector4()\n\nconst _ssOrigin = new Vector4()\nconst _ssOrigin3 = new Vector3()\nconst _mvMatrix = new Matrix4()\nconst _line = new Line3()\nconst _closestPoint = new Vector3()\n\nconst _box = new Box3()\nconst _sphere = new Sphere()\nconst _clipToWorldVector = new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld);\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { LineSegments2 }\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super()\n\n    this.isLineGeometry = true\n\n    this.type = 'LineGeometry'\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n    const length = array.length - 3\n    const points = new Float32Array(2 * length)\n\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i]\n      points[2 * i + 1] = array[i + 1]\n      points[2 * i + 2] = array[i + 2]\n\n      points[2 * i + 3] = array[i + 3]\n      points[2 * i + 4] = array[i + 4]\n      points[2 * i + 5] = array[i + 5]\n    }\n\n    super.setPositions(points)\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    // converts [ r1, g1, b1, (a1),  r2, g2, b2, (a2), ... ] to pairs format\n\n    const length = array.length - itemSize\n    const colors = new Float32Array(2 * length)\n\n    if (itemSize === 3) {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n\n        colors[2 * i + 3] = array[i + 3]\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n      }\n    } else {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n        colors[2 * i + 3] = array[i + 3]\n\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n        colors[2 * i + 6] = array[i + 6]\n        colors[2 * i + 7] = array[i + 7]\n      }\n    }\n\n    super.setColors(colors, itemSize)\n\n    return this\n  }\n\n  fromLine(line) {\n    const geometry = line.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n}\n\nexport { LineGeometry }\n","import { LineSegments2 } from '../lines/LineSegments2'\nimport { LineGeometry } from '../lines/LineGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLine2 = true\n\n    this.type = 'Line2'\n  }\n}\n\nexport { Line2 }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Vector3, Vector4, Vector2, Color } from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { LineSegments2, Line2, LineMaterial, LineSegmentsGeometry, LineGeometry } from 'three-stdlib';\n\nconst Line = /* @__PURE__ */React.forwardRef(function Line({\n  points,\n  color = 0xffffff,\n  vertexColors,\n  linewidth,\n  lineWidth,\n  segments,\n  dashed,\n  ...rest\n}, ref) {\n  var _vertexColors$, _ref;\n  const size = useThree(state => state.size);\n  const line2 = React.useMemo(() => segments ? new LineSegments2() : new Line2(), [segments]);\n  const [lineMaterial] = React.useState(() => new LineMaterial());\n  const itemSize = (vertexColors == null || (_vertexColors$ = vertexColors[0]) == null ? void 0 : _vertexColors$.length) === 4 ? 4 : 3;\n  const lineGeom = React.useMemo(() => {\n    const geom = segments ? new LineSegmentsGeometry() : new LineGeometry();\n    const pValues = points.map(p => {\n      const isArray = Array.isArray(p);\n      return p instanceof Vector3 || p instanceof Vector4 ? [p.x, p.y, p.z] : p instanceof Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n    });\n    geom.setPositions(pValues.flat());\n    if (vertexColors) {\n      // using vertexColors requires the color value to be white see #1813\n      color = 0xffffff;\n      const cValues = vertexColors.map(c => c instanceof Color ? c.toArray() : c);\n      geom.setColors(cValues.flat(), itemSize);\n    }\n    return geom;\n  }, [points, segments, vertexColors, itemSize]);\n  React.useLayoutEffect(() => {\n    line2.computeLineDistances();\n  }, [points, line2]);\n  React.useLayoutEffect(() => {\n    if (dashed) {\n      lineMaterial.defines.USE_DASH = '';\n    } else {\n      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.\n      delete lineMaterial.defines.USE_DASH;\n    }\n    lineMaterial.needsUpdate = true;\n  }, [dashed, lineMaterial]);\n  React.useEffect(() => {\n    return () => {\n      lineGeom.dispose();\n      lineMaterial.dispose();\n    };\n  }, [lineGeom]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: line2,\n    ref: ref\n  }, rest), /*#__PURE__*/React.createElement(\"primitive\", {\n    object: lineGeom,\n    attach: \"geometry\"\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: lineMaterial,\n    attach: \"material\",\n    color: color,\n    vertexColors: Boolean(vertexColors),\n    resolution: [size.width, size.height],\n    linewidth: (_ref = linewidth !== null && linewidth !== void 0 ? linewidth : lineWidth) !== null && _ref !== void 0 ? _ref : 1,\n    dashed: dashed,\n    transparent: itemSize === 4\n  }, rest)));\n});\n\nexport { Line };\n","import { useSphere } from '@react-three/cannon';\nimport { useEffect, useRef, useState } from 'react';\nimport { useTexture } from '@react-three/drei';\nimport plopSound from '../../sounds/plop.mp3';\nimport ballLogo from '../../imgs/logo.jpg';\nimport { Line } from '@react-three/drei';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { decrementLife, incrementLife } from '../../redux/slices/userSlice';\nimport { checkBall, OutsideBall } from 'components/GameLogic/GameLogic';\nimport { setBounce } from '../../redux/slices/gameSlice';\n\n// --------------------------------------- I M P O R T S\n\nconst plop = new Audio(plopSound);\n\nconst TrajectoryLine = ({ points }) => {\n  return <Line points={points} color=\"blue\" lineWidth={0.4} />;\n};\n\nconst Ball = ({ args = [1, 64, 64], onReset, ballId }) => {\n  const [isFloating, setIsFloating] = useState(false);\n  const [trajectoryPoints, setTrajectoryPoints] = useState([]);\n  const outBallsArrRef = useRef([]);\n  const dispatch = useDispatch();\n\n  const [ref, api] = useSphere(() => ({\n    args: [1],\n    mass: 1,\n    material: { restitution: 0.95 },\n    position: [Math.random() * 20 - 10, 30, 0],\n    onCollide: event => {\n      if (event.body.userData?.type === 'playPlatform') {\n        dispatch(setBounce());\n      }\n    },\n  }));\n  const life = useSelector(state => state.user.life);\n\n  useEffect(() => {\n    const unsubscribe = api.position.subscribe(position => {\n      // --------------------------------------- IS BALL OUT ?\n      const isOut = OutsideBall(position, ballId, outBallsArrRef);\n      if (isOut) {\n        dispatch(incrementLife());\n      }\n\n      // --------------------------------------- IS BALL FALL ?\n      if (checkBall(position) && !isFloating) {\n        setIsFloating(true);\n        api.velocity.set(0, 0, 0);\n        api.position.set(position[0], 0.5, position[2]);\n        api.mass.set(0);\n\n        plop.currentTime = 0;\n        plop.play();\n\n        dispatch(decrementLife());\n\n        if (life > 1) {\n          onReset();\n        }\n      }\n\n      const center = [position[0], position[1], position[2]];\n      const groundPoint = [position[0], 0, position[2]];\n      setTrajectoryPoints([center, groundPoint]);\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [\n    api.position,\n    onReset,\n    isFloating,\n    api.velocity,\n    api.mass,\n    dispatch,\n    life,\n    ballId,\n  ]);\n\n  return (\n    <>\n      {trajectoryPoints.length === 2 && (\n        <TrajectoryLine points={trajectoryPoints} />\n      )}\n      <mesh ref={ref}>\n        <sphereGeometry args={args} />\n        <meshStandardMaterial\n          map={useTexture(ballLogo)}\n          roughness={0}\n          thickness={10}\n          envMapIntensity={1}\n          color=\"orange\"\n        />\n      </mesh>\n    </>\n  );\n};\n\nexport default Ball;\n","// GameLogic.js\n\nimport { toast } from 'react-toastify';\n\n// --------------------------------------- IS BALL in the Ocean\nexport const checkBall = position => {\n  return position[1] <= 0;\n};\n\n// --------------------------------------- IS BALL OUT ?\n\nexport const OutsideBall = (position, ballId, outBallsArrRef) => {\n  const isOut =\n    position[0] > 38 ||\n    position[0] < -38 ||\n    position[2] > 38 ||\n    position[2] < -38;\n\n  if (isOut && !outBallsArrRef.current.includes(ballId)) {\n    outBallsArrRef.current.push(ballId);\n\n    toast.warn('BALL OUT', { position: 'top-left', theme: 'colored' });\n\n    return true;\n  }\n\n  return false;\n};\n"],"names":["IsObject","url","Object","Array","isArray","useTexture","input","onLoad","gl","useThree","state","textures","useLoader","TextureLoader","values","useLayoutEffect","useEffect","textureArray","Texture$1","forEach","texture","initTexture","useMemo","keyed","i","key","preload","clear","_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","constructor","super","this","isLineSegmentsGeometry","type","setIndex","setAttribute","Float32BufferAttribute","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","itemSize","arguments","length","undefined","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegments","setFromBufferAttribute","union","Sphere","center","getCenter","maxRadiusSq","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn","LineMaterial","ShaderMaterial","parameters","uniforms","UniformsUtils","clone","merge","UniformsLib","common","fog","worldUnits","value","linewidth","resolution","Vector2","dashOffset","dashScale","dashSize","gapSize","vertexShader","fragmentShader","parseInt","REVISION","replace","clipping","isLineMaterial","onBeforeCompile","transparent","defines","USE_LINE_COLOR_ALPHA","defineProperties","color","enumerable","get","diffuse","set","WORLD_UNITS","dashed","Boolean","USE_DASH","opacity","copy","alphaToCoverage","USE_ALPHA_TO_COVERAGE","extensions","derivatives","setValues","UV1","version","_viewport","Vector4","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","abs","LineSegments2","Mesh","random","isLineSegments2","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","material","threshold","params","Line2","ray","matrixWorld","sphereMargin","boxMargin","near","distanceToPoint","origin","intersectsSphere","expandByScalar","intersectsBox","min","instanceCount","pointOnLine","point","distanceSqToSegment","push","object","face","faceIndex","uv","raycastWorldUnits","segmentCount","at","matrixWorldInverse","z","multiplyMatrices","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","isInside","raycastScreenSpace","onBeforeRender","renderer","getViewport","LineGeometry","isLineGeometry","points","fromLine","line","isLine2","Line","React","_ref2","ref","vertexColors","lineWidth","segments","rest","_vertexColors$","_ref","size","line2","lineMaterial","lineGeom","geom","pValues","map","p","flat","cValues","c","Color","toArray","dispose","_extends","attach","plop","Audio","plopSound","TrajectoryLine","_jsx","args","onReset","ballId","isFloating","setIsFloating","useState","trajectoryPoints","setTrajectoryPoints","outBallsArrRef","useRef","dispatch","useDispatch","api","useSphere","mass","restitution","onCollide","event","_event$body$userData","body","userData","setBounce","life","useSelector","user","unsubscribe","subscribe","isOut","OutsideBall","current","includes","toast","theme","incrementLife","checkBall","velocity","currentTime","play","decrementLife","groundPoint","_jsxs","_Fragment","children","ballLogo","roughness","thickness","envMapIntensity"],"sourceRoot":""}