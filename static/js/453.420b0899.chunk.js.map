{"version":3,"file":"static/js/453.420b0899.chunk.js","mappings":"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","sources":["../node_modules/src/objects/Water.js","components/Ocean/Ocean.jsx"],"sourcesContent":["import {\n  Color,\n  FrontSide,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  REVISION,\n} from 'three'\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isWater = true\n\n    const scope = this\n\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512\n\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0\n    const time = options.time !== undefined ? options.time : 0.0\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0)\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff)\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f)\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0)\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0\n    const side = options.side !== undefined ? options.side : FrontSide\n    const fog = options.fog !== undefined ? options.fog : false\n\n    //\n\n    const mirrorPlane = new Plane()\n    const normal = new Vector3()\n    const mirrorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n    const clipPlane = new Vector4()\n\n    const view = new Vector3()\n    const target = new Vector3()\n    const q = new Vector4()\n\n    const textureMatrix = new Matrix4()\n\n    const mirrorCamera = new PerspectiveCamera()\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight)\n\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([\n        UniformsLib['fog'],\n        UniformsLib['lights'],\n        {\n          normalSampler: { value: null },\n          mirrorSampler: { value: null },\n          alpha: { value: 1.0 },\n          time: { value: 0.0 },\n          size: { value: 1.0 },\n          distortionScale: { value: 20.0 },\n          textureMatrix: { value: new Matrix4() },\n          sunColor: { value: new Color(0x7f7f7f) },\n          sunDirection: { value: new Vector3(0.70707, 0.70707, 0) },\n          eye: { value: new Vector3() },\n          waterColor: { value: new Color(0x555555) },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`,\n    }\n\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog,\n    })\n\n    material.uniforms['mirrorSampler'].value = renderTarget.texture\n    material.uniforms['textureMatrix'].value = textureMatrix\n    material.uniforms['alpha'].value = alpha\n    material.uniforms['time'].value = time\n    material.uniforms['normalSampler'].value = normalSampler\n    material.uniforms['sunColor'].value = sunColor\n    material.uniforms['waterColor'].value = waterColor\n    material.uniforms['sunDirection'].value = sunDirection\n    material.uniforms['distortionScale'].value = distortionScale\n\n    material.uniforms['eye'].value = eye\n\n    scope.material = material\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(mirrorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(mirrorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(mirrorWorldPosition)\n\n      mirrorCamera.position.copy(view)\n      mirrorCamera.up.set(0, 1, 0)\n      mirrorCamera.up.applyMatrix4(rotationMatrix)\n      mirrorCamera.up.reflect(normal)\n      mirrorCamera.lookAt(target)\n\n      mirrorCamera.far = camera.far // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld()\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(mirrorCamera.projectionMatrix)\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse)\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition)\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse)\n\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant)\n\n      const projectionMatrix = mirrorCamera.projectionMatrix\n\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n      q.z = -1.0\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q))\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x\n      projectionMatrix.elements[6] = clipPlane.y\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias\n      projectionMatrix.elements[14] = clipPlane.w\n\n      eye.setFromMatrixPosition(camera.matrixWorld)\n\n      // Render\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n\n      scope.visible = false\n\n      renderer.xr.enabled = false // Avoid camera modification and recursion\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, mirrorCamera)\n\n      scope.visible = true\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n    }\n  }\n}\n\nexport { Water }\n","import * as THREE from 'three';\nimport { extend, useFrame, useLoader, useThree } from '@react-three/fiber';\nimport { useMemo, useRef } from 'react';\nimport { Water } from 'three-stdlib';\nimport { TextureLoader } from 'three';\nimport waterTexture from '../../imgs/waternormals.jpeg';\n\nextend({ Water });\n\nconst Ocean = () => {\n  const ref = useRef();\n  const gl = useThree(state => state.gl);\n  const waterNormals = useLoader(TextureLoader, waterTexture);\n  waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;\n  const geom = useMemo(() => new THREE.PlaneGeometry(10000, 10000), []);\n\n  const config = useMemo(\n    () => ({\n      textureWidth: 512,\n      textureHeight: 512,\n      waterNormals,\n      sunDirection: new THREE.Vector3(),\n      sunColor: 0x0000ff,\n      waterColor: 0x0055df,\n      distortionScale: 3.7,\n      fog: true,\n      format: gl.encoding,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [waterNormals]\n  );\n\n  useFrame((state, delta) => {\n    ref.current.material.uniforms.time.value += delta * 0.4;\n  });\n\n  return (\n    <>\n      <water ref={ref} args={[geom, config]} rotation-x={-Math.PI / 2} />\n    </>\n  );\n};\n\nexport default Ocean;\n"],"names":["Water","Mesh","constructor","geometry","options","arguments","length","undefined","super","this","isWater","scope","textureWidth","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","renderTarget","WebGLRenderTarget","mirrorShader","uniforms","UniformsUtils","merge","UniformsLib","value","mirrorSampler","size","vertexShader","fragmentShader","parseInt","REVISION","replace","material","ShaderMaterial","clone","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","extend","Ocean","ref","useRef","gl","useThree","useLoader","TextureLoader","waterTexture","wrapS","wrapT","THREE","geom","useMemo","config","format","encoding","useFrame","delta","current","_jsx","_Fragment","children","args","PI"],"sourceRoot":""}