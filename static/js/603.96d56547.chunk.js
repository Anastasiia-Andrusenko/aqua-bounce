"use strict";(self.webpackChunkaqua_bounce=self.webpackChunkaqua_bounce||[]).push([[603],{7965:(t,e,n)=>{n.r(e),n.d(e,{default:()=>F});var i=n(5319),r=n(2483),o=n(4406),s=n(7787);const a=t=>t===Object(t)&&!Array.isArray(t)&&"function"!==typeof t;function l(t,e){const n=(0,s.D)((t=>t.gl)),i=(0,s.H)(o.TextureLoader,a(t)?Object.values(t):t);(0,r.useLayoutEffect)((()=>{null==e||e(i)}),[e]),(0,r.useEffect)((()=>{if("initTexture"in n){let t=[];Array.isArray(i)?t=i:i instanceof o.Texture?t=[i]:a(i)&&(t=Object.values(i)),t.forEach((t=>{t instanceof o.Texture&&n.initTexture(t)}))}}),[n,i]);return(0,r.useMemo)((()=>{if(a(t)){const e={};let n=0;for(const r in t)e[r]=i[n++];return e}return i}),[t,i])}l.preload=t=>s.H.preload(o.TextureLoader,t),l.clear=t=>s.H.clear(o.TextureLoader,t);const d=n.p+"static/media/plop.9cb7ad13460051e22d5b.mp3",c=n.p+"static/media/logo.0fce2da1d51f39d8b7c9.jpg";var f=n(8168);const u=new o.Box3,p=new o.Vector3;class h extends o.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new o.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new o.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new o.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceStart",new o.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new o.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const i=new o.InstancedInterleavedBuffer(e,2*n,1);return this.setAttribute("instanceColorStart",new o.InterleavedBufferAttribute(i,n,0)),this.setAttribute("instanceColorEnd",new o.InterleavedBufferAttribute(i,n,n)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new o.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new o.Box3);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),u.setFromBufferAttribute(e),this.boundingBox.union(u))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new o.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let r=0,o=t.count;r<o;r++)p.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(p)),p.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(p));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}class m extends o.ShaderMaterial{constructor(t){super({type:"LineMaterial",uniforms:o.UniformsUtils.clone(o.UniformsUtils.merge([o.UniformsLib.common,o.UniformsLib.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new o.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:"\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:`\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(o.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`,clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return Boolean("USE_DASH"in this.defines)},set(t){Boolean(t)!==Boolean("USE_DASH"in this.defines)&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)},set:function(t){Boolean(t)!==Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)&&(this.needsUpdate=!0),!0===t?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(t)}}const v=n(3416).r>=125?"uv1":"uv2",y=new o.Vector4,g=new o.Vector3,S=new o.Vector3,w=new o.Vector4,b=new o.Vector4,x=new o.Vector4,E=new o.Vector3,A=new o.Matrix4,_=new o.Line3,L=new o.Vector3,U=new o.Box3,B=new o.Sphere,z=new o.Vector4;let M,O;function C(t,e,n){return z.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),z.multiplyScalar(1/z.w),z.x=O/n.width,z.y=O/n.height,z.applyMatrix4(t.projectionMatrixInverse),z.multiplyScalar(1/z.w),Math.abs(Math.max(z.x,z.y))}class D extends o.Mesh{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,arguments.length>1&&void 0!==arguments[1]?arguments[1]:new m({color:16777215*Math.random()})),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let o=0,s=0,a=e.count;o<a;o++,s+=2)g.fromBufferAttribute(e,o),S.fromBufferAttribute(n,o),i[s]=0===s?0:i[s-1],i[s+1]=i[s]+g.distanceTo(S);const r=new o.InstancedInterleavedBuffer(i,2,1);return t.setAttribute("instanceDistanceStart",new o.InterleavedBufferAttribute(r,1,0)),t.setAttribute("instanceDistanceEnd",new o.InterleavedBufferAttribute(r,1,1)),this}raycast(t,e){const n=this.material.worldUnits,i=t.camera;null!==i||n||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=void 0!==t.params.Line2&&t.params.Line2.threshold||0;M=t.ray;const s=this.matrixWorld,a=this.geometry,l=this.material;let d,c;if(O=l.linewidth+r,null===a.boundingSphere&&a.computeBoundingSphere(),B.copy(a.boundingSphere).applyMatrix4(s),n)d=.5*O;else{d=C(i,Math.max(i.near,B.distanceToPoint(M.origin)),l.resolution)}if(B.radius+=d,!1!==M.intersectsSphere(B)){if(null===a.boundingBox&&a.computeBoundingBox(),U.copy(a.boundingBox).applyMatrix4(s),n)c=.5*O;else{c=C(i,Math.max(i.near,U.distanceToPoint(M.origin)),l.resolution)}U.expandByScalar(c),!1!==M.intersectsBox(U)&&(n?function(t,e){const n=t.matrixWorld,i=t.geometry,r=i.attributes.instanceStart,s=i.attributes.instanceEnd;for(let a=0,l=Math.min(i.instanceCount,r.count);a<l;a++){_.start.fromBufferAttribute(r,a),_.end.fromBufferAttribute(s,a),_.applyMatrix4(n);const i=new o.Vector3,l=new o.Vector3;M.distanceSqToSegment(_.start,_.end,l,i),l.distanceTo(i)<.5*O&&e.push({point:l,pointOnLine:i,distance:M.origin.distanceTo(l),object:t,face:null,faceIndex:a,uv:null,[v]:null})}}(this,e):function(t,e,n){const i=e.projectionMatrix,r=t.material.resolution,s=t.matrixWorld,a=t.geometry,l=a.attributes.instanceStart,d=a.attributes.instanceEnd,c=Math.min(a.instanceCount,l.count),f=-e.near;M.at(1,x),x.w=1,x.applyMatrix4(e.matrixWorldInverse),x.applyMatrix4(i),x.multiplyScalar(1/x.w),x.x*=r.x/2,x.y*=r.y/2,x.z=0,E.copy(x),A.multiplyMatrices(e.matrixWorldInverse,s);for(let u=0,p=c;u<p;u++){if(w.fromBufferAttribute(l,u),b.fromBufferAttribute(d,u),w.w=1,b.w=1,w.applyMatrix4(A),b.applyMatrix4(A),w.z>f&&b.z>f)continue;if(w.z>f){const t=w.z-b.z,e=(w.z-f)/t;w.lerp(b,e)}else if(b.z>f){const t=b.z-w.z,e=(b.z-f)/t;b.lerp(w,e)}w.applyMatrix4(i),b.applyMatrix4(i),w.multiplyScalar(1/w.w),b.multiplyScalar(1/b.w),w.x*=r.x/2,w.y*=r.y/2,b.x*=r.x/2,b.y*=r.y/2,_.start.copy(w),_.start.z=0,_.end.copy(b),_.end.z=0;const e=_.closestPointToPointParameter(E,!0);_.at(e,L);const a=o.MathUtils.lerp(w.z,b.z,e),c=a>=-1&&a<=1,p=E.distanceTo(L)<.5*O;if(c&&p){_.start.fromBufferAttribute(l,u),_.end.fromBufferAttribute(d,u),_.start.applyMatrix4(s),_.end.applyMatrix4(s);const e=new o.Vector3,i=new o.Vector3;M.distanceSqToSegment(_.start,_.end,i,e),n.push({point:i,pointOnLine:e,distance:M.origin.distanceTo(i),object:t,face:null,faceIndex:u,uv:null,[v]:null})}}}(this,i,e))}}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(y),this.material.uniforms.resolution.value.set(y.z,y.w))}}class T extends h{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,n=new Float32Array(2*e);for(let i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return super.setPositions(n),this}setColors(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=t.length-e,i=new Float32Array(2*n);if(3===e)for(let r=0;r<n;r+=e)i[2*r]=t[r],i[2*r+1]=t[r+1],i[2*r+2]=t[r+2],i[2*r+3]=t[r+3],i[2*r+4]=t[r+4],i[2*r+5]=t[r+5];else for(let r=0;r<n;r+=e)i[2*r]=t[r],i[2*r+1]=t[r+1],i[2*r+2]=t[r+2],i[2*r+3]=t[r+3],i[2*r+4]=t[r+4],i[2*r+5]=t[r+5],i[2*r+6]=t[r+6],i[2*r+7]=t[r+7];return super.setColors(i,e),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class I extends D{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new T,arguments.length>1&&void 0!==arguments[1]?arguments[1]:new m({color:16777215*Math.random()})),this.isLine2=!0,this.type="Line2"}}const P=r.forwardRef((function(t,e){let{points:n,color:i=16777215,vertexColors:a,linewidth:l,lineWidth:d,segments:c,dashed:u,...p}=t;var v,y;const g=(0,s.D)((t=>t.size)),S=r.useMemo((()=>c?new D:new I),[c]),[w]=r.useState((()=>new m)),b=4===(null==a||null==(v=a[0])?void 0:v.length)?4:3,x=r.useMemo((()=>{const t=c?new h:new T,e=n.map((t=>{const e=Array.isArray(t);return t instanceof o.Vector3||t instanceof o.Vector4?[t.x,t.y,t.z]:t instanceof o.Vector2?[t.x,t.y,0]:e&&3===t.length?[t[0],t[1],t[2]]:e&&2===t.length?[t[0],t[1],0]:t}));if(t.setPositions(e.flat()),a){i=16777215;const e=a.map((t=>t instanceof o.Color?t.toArray():t));t.setColors(e.flat(),b)}return t}),[n,c,a,b]);return r.useLayoutEffect((()=>{S.computeLineDistances()}),[n,S]),r.useLayoutEffect((()=>{u?w.defines.USE_DASH="":delete w.defines.USE_DASH,w.needsUpdate=!0}),[u,w]),r.useEffect((()=>()=>{x.dispose(),w.dispose()}),[x]),r.createElement("primitive",(0,f.A)({object:S,ref:e},p),r.createElement("primitive",{object:x,attach:"geometry"}),r.createElement("primitive",(0,f.A)({object:w,attach:"material",color:i,vertexColors:Boolean(a),resolution:[g.width,g.height],linewidth:null!==(y=null!==l&&void 0!==l?l:d)&&void 0!==y?y:1,dashed:u,transparent:4===b},p)))}));var j=n(1965),R=n(6750),H=n(1734);var V=n(9),N=n(6723);const W=new Audio(d),G=t=>{let{points:e}=t;return(0,N.jsx)(P,{points:e,color:"blue",lineWidth:.4})},F=t=>{let{args:e=[1,64,64],onReset:n,ballId:o}=t;const[s,a]=(0,r.useState)(!1),[d,f]=(0,r.useState)([]),u=(0,r.useRef)([]),p=(0,j.wA)(),[h,m]=(0,i.l4)((()=>({args:[1],mass:1,material:{restitution:.95},position:[20*Math.random()-10,30,0],onCollide:t=>{var e;"playPlatform"===(null===(e=t.body.userData)||void 0===e?void 0:e.type)&&p((0,V.dn)())}}))),v=(0,j.d4)((t=>t.user.life));return(0,r.useEffect)((()=>{const t=m.position.subscribe((t=>{const e=((t,e,n)=>!(!(t[0]>38||t[0]<-38||t[2]>38||t[2]<-38)||n.current.includes(e))&&(n.current.push(e),H.oR.warn("BALL OUT",{position:"top-left",theme:"colored"}),!0))(t,o,u);e&&p((0,R.ys)()),(t=>t[1]<=0)(t)&&!s&&(a(!0),m.velocity.set(0,0,0),m.position.set(t[0],.5,t[2]),m.mass.set(0),W.currentTime=0,W.play(),p((0,R.Qn)()),v>1&&n());const i=[t[0],t[1],t[2]],r=[t[0],0,t[2]];f([i,r])}));return()=>{t()}}),[m.position,n,s,m.velocity,m.mass,p,v,o]),(0,N.jsxs)(N.Fragment,{children:[2===d.length&&(0,N.jsx)(G,{points:d}),(0,N.jsxs)("mesh",{ref:h,children:[(0,N.jsx)("sphereGeometry",{args:e}),(0,N.jsx)("meshStandardMaterial",{map:l(c),roughness:0,thickness:10,envMapIntensity:1,color:"orange"})]})]})}}}]);
//# sourceMappingURL=603.96d56547.chunk.js.map